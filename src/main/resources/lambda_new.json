{
  "packages": [
    {
      "name": "nextgen.lambda.domain.maven",
      "entities": [
        {
          "name": "Project",
          "scope": "public",
          "extends": "",
          "fields": [
            {
              "name": "name",
              "type": "String"
            },
            {
              "name": "root",
              "type": "String"
            }
          ],
          "methods": [
            {
              "type": "String",
              "name": "name",
              "scope": "public",
              "parameters": [],
              "statements": [
                "return this.name;"
              ],
              "annotations": []
            },
            {
              "type": "String",
              "name": "root",
              "scope": "public",
              "parameters": [],
              "statements": [
                "return this.root;"
              ],
              "annotations": []
            },
            {
              "type": "String",
              "name": "srcMain",
              "scope": "public",
              "parameters": [],
              "statements": [
                "return root + java.io.File.separator + \"src/main\";"
              ],
              "annotations": []
            },
            {
              "type": "String",
              "name": "srcMainJava",
              "scope": "public",
              "parameters": [],
              "statements": [
                "return srcMain() + java.io.File.separator + \"java\";"
              ],
              "annotations": []
            },
            {
              "type": "String",
              "name": "srcMainResources",
              "scope": "public",
              "parameters": [],
              "statements": [
                "return srcMain() + java.io.File.separator + \"resources\";"
              ],
              "annotations": []
            }
          ],
          "constructors": [
            {
              "name": "Project",
              "scope": "public",
              "parameters": [
                {
                  "name": "name",
                  "type": "String"
                },
                {
                  "name": "root",
                  "type": "String"
                }
              ],
              "statements": [
                "this.name = name;",
                "this.root = root;"
              ],
              "annotations": []
            }
          ],
          "nested": [],
          "annotations": [],
          "typeParameters": []
        }
      ],
      "interfaces": [],
      "enums": []
    },
    {
      "name": "nextgen.lambda.domain.actions",
      "entities": [],
      "interfaces": [
        {
          "name": "Task",
          "scope": "public",
          "extends": "",
          "fields": [],
          "methods": [
            {
              "type": "T",
              "name": "run",
              "scope": "",
              "parameters": [],
              "statements": [],
              "annotations": []
            }
          ],
          "constructors": [],
          "nested": [],
          "annotations": [
            {
              "name": "FunctionalInterface"
            }
          ],
          "typeParameters": [
            "T"
          ]
        }
      ],
      "enums": []
    },
    {
      "name": "nextgen.lambda.domain.graph",
      "entities": [
        {
          "name": "Graph",
          "scope": "public",
          "extends": "",
          "fields": [],
          "methods": [],
          "constructors": [],
          "nested": [],
          "annotations": [],
          "typeParameters": []
        },
        {
          "name": "Visitor",
          "scope": "public",
          "extends": "",
          "fields": [],
          "methods": [],
          "constructors": [],
          "nested": [],
          "annotations": [],
          "typeParameters": []
        },
        {
          "name": "Relation",
          "scope": "public",
          "extends": "",
          "fields": [],
          "methods": [],
          "constructors": [],
          "nested": [],
          "annotations": [],
          "typeParameters": []
        },
        {
          "name": "Node",
          "scope": "public",
          "extends": "",
          "fields": [],
          "methods": [],
          "constructors": [],
          "nested": [],
          "annotations": [],
          "typeParameters": []
        }
      ],
      "interfaces": [],
      "enums": []
    },
    {
      "name": "nextgen.lambda.domain.templates",
      "entities": [
        {
          "name": "TemplateGroup",
          "scope": "public",
          "extends": "",
          "fields": [
            {
              "name": "delegate",
              "type": "io.vertx.core.json.JsonObject"
            },
            {
              "name": "stGroup",
              "type": "org.stringtemplate.v4.STGroup"
            }
          ],
          "methods": [
            {
              "type": "String",
              "name": "name",
              "scope": "public",
              "parameters": [],
              "statements": [
                "return delegate.getString(\"name\");"
              ],
              "annotations": []
            },
            {
              "type": "java.util.stream.Stream<Template>",
              "name": "templates",
              "scope": "public",
              "parameters": [],
              "statements": [
                "return delegate.getJsonArray(\"templates\", new io.vertx.core.json.JsonArray()).stream().map(element -> (io.vertx.core.json.JsonObject) element).map(Template::new);"
              ],
              "annotations": []
            },
            {
              "type": "org.stringtemplate.v4.STGroup",
              "name": "stGroup",
              "scope": "public",
              "parameters": [],
              "statements": [
                "return stGroup;"
              ],
              "annotations": []
            },
            {
              "type": "String",
              "name": "toSTG",
              "scope": "public",
              "parameters": [],
              "statements": [
                "final String stg = \"delimiters \\\"~\\\", \\\"~\\\"\" + \"\\n\\ngt() ::= \\\">\\\"\" + \"\\n\\neot() ::= <<~gt()~~gt()~>>\" + \"\\n\\nSTGroupTemplate(DELIMITER,TEMPLATES) ::= <<delimiters \\\"~DELIMITER~\\\",\\\"~DELIMITER~\\\"\" + \"\\n\\n~TEMPLATES:{it|~it~};separator=\\\"\\\\n\\\\n\\\"~\" + \"\\n\\neom() ::= \\\"}\\\"\" + \"\\n\\ngt() ::= \\\">\\\"\" + \"\\n\\n>>\" + \"\\n\\nSTTemplate(CONTENT,NAME,PARAMS) ::= <<~NAME~(~PARAMS:{it|~it~};separator=\\\",\\\"~) ::= <<~CONTENT~ ~eot()~>>\";",
                "final org.stringtemplate.v4.STGroup templateGroup = new org.stringtemplate.v4.STGroupString(name(), stg, '~', '~');",
                "final org.stringtemplate.v4.ST stGroupTemplate = templateGroup.getInstanceOf(\"STGroupTemplate\");",
                "stGroupTemplate.add(\"DELIMITER\", \"~\");",
                "templates().filter(template -> !template.name().equals(\"eom\")).filter(template -> !template.name().equals(\"gt\")).forEach(template -> {\n    final org.stringtemplate.v4.ST stTemplate = templateGroup.getInstanceOf(\"STTemplate\");\n    stTemplate.add(\"NAME\", template.name());\n    stTemplate.add(\"CONTENT\", template.content());\n    template.parameters().forEach(parameter -> stTemplate.add(\"PARAMS\", parameter.name()));\n    stGroupTemplate.add(\"TEMPLATES\", stTemplate);\n});",
                "final org.stringtemplate.v4.STGroup stGroup = new org.stringtemplate.v4.STGroupString(name(), stGroupTemplate.render(), '~', '~');",
                "stGroup.registerRenderer(Object.class, (o, formatString, locale) -> {\n    final String text = o.toString();\n    if (formatString == null)\n        return text;\n    final int length = text.length();\n    final int lastIndex = text.lastIndexOf(\".\");\n    switch(formatString) {\n        case \"sn\":\n        case \"simpleName\":\n            if (lastIndex == -1)\n                return text;\n            return text.substring(lastIndex + 1);\n        case \"cap\":\n        case \"capitalize\":\n            return Character.toUpperCase(text.charAt(0)) + (length > 1 ? text.substring(1) : \"\");\n        case \"tu\":\n        case \"toUpper\":\n            return text.toUpperCase();\n        case \"lf\":\n        case \"lowFirst\":\n            return Character.toLowerCase(text.charAt(0)) + (length > 1 ? text.substring(1) : \"\");\n        case \"tl\":\n        case \"toLower\":\n            return text.toLowerCase();\n        default:\n            return o.toString();\n    }\n});",
                "return stGroupTemplate.render();"
              ],
              "annotations": []
            }
          ],
          "constructors": [
            {
              "name": "TemplateGroup",
              "scope": "public",
              "parameters": [
                {
                  "name": "delegate",
                  "type": "io.vertx.core.json.JsonObject"
                }
              ],
              "statements": [
                "this.delegate = delegate;",
                "this.stGroup = new org.stringtemplate.v4.STGroupString(name(), toSTG(), '~', '~');"
              ],
              "annotations": []
            }
          ],
          "nested": [],
          "annotations": [],
          "typeParameters": []
        },
        {
          "name": "TemplateParameter",
          "scope": "public",
          "extends": "",
          "fields": [
            {
              "name": "delegate",
              "type": "io.vertx.core.json.JsonObject"
            }
          ],
          "methods": [
            {
              "type": "String",
              "name": "name",
              "scope": "public",
              "parameters": [],
              "statements": [
                "return delegate.getString(\"name\");"
              ],
              "annotations": []
            },
            {
              "type": "String",
              "name": "qty",
              "scope": "public",
              "parameters": [],
              "statements": [
                "return delegate.getString(\"qty\");"
              ],
              "annotations": []
            }
          ],
          "constructors": [
            {
              "name": "TemplateParameter",
              "scope": "public",
              "parameters": [
                {
                  "name": "delegate",
                  "type": "io.vertx.core.json.JsonObject"
                }
              ],
              "statements": [
                "this.delegate = delegate;"
              ],
              "annotations": []
            }
          ],
          "nested": [],
          "annotations": [],
          "typeParameters": []
        },
        {
          "name": "Template",
          "scope": "public",
          "extends": "",
          "fields": [
            {
              "name": "delegate",
              "type": "io.vertx.core.json.JsonObject"
            }
          ],
          "methods": [
            {
              "type": "String",
              "name": "name",
              "scope": "public",
              "parameters": [],
              "statements": [
                "return delegate.getString(\"name\");"
              ],
              "annotations": []
            },
            {
              "type": "String",
              "name": "content",
              "scope": "public",
              "parameters": [],
              "statements": [
                "return delegate.getString(\"content\");"
              ],
              "annotations": []
            },
            {
              "type": "java.util.stream.Stream<TemplateParameter>",
              "name": "parameters",
              "scope": "public",
              "parameters": [],
              "statements": [
                "return delegate.getJsonArray(\"parameters\", new io.vertx.core.json.JsonArray()).stream().map(element -> (io.vertx.core.json.JsonObject) element).map(TemplateParameter::new);"
              ],
              "annotations": []
            }
          ],
          "constructors": [
            {
              "name": "Template",
              "scope": "public",
              "parameters": [
                {
                  "name": "delegate",
                  "type": "io.vertx.core.json.JsonObject"
                }
              ],
              "statements": [
                "this.delegate = delegate;"
              ],
              "annotations": []
            }
          ],
          "nested": [],
          "annotations": [],
          "typeParameters": []
        }
      ],
      "interfaces": [],
      "enums": []
    },
    {
      "name": "nextgen.lambda.domain.core",
      "entities": [
        {
          "name": "Field",
          "scope": "public",
          "extends": "",
          "fields": [
            {
              "name": "delegate",
              "type": "io.vertx.core.json.JsonObject"
            }
          ],
          "methods": [
            {
              "type": "String",
              "name": "name",
              "scope": "public",
              "parameters": [],
              "statements": [
                "return delegate.getString(\"name\");"
              ],
              "annotations": []
            },
            {
              "type": "String",
              "name": "type",
              "scope": "public",
              "parameters": [],
              "statements": [
                "return delegate.getString(\"type\");"
              ],
              "annotations": []
            }
          ],
          "constructors": [
            {
              "name": "Field",
              "scope": "public",
              "parameters": [
                {
                  "name": "delegate",
                  "type": "io.vertx.core.json.JsonObject"
                }
              ],
              "statements": [
                "this.delegate = delegate;"
              ],
              "annotations": []
            }
          ],
          "nested": [],
          "annotations": [],
          "typeParameters": []
        },
        {
          "name": "Statement",
          "scope": "public",
          "extends": "",
          "fields": [
            {
              "name": "delegate",
              "type": "io.vertx.core.json.JsonObject"
            }
          ],
          "methods": [
            {
              "type": "String",
              "name": "expression",
              "scope": "public",
              "parameters": [],
              "statements": [
                "return delegate.getString(\"expression\");"
              ],
              "annotations": []
            },
            {
              "type": "String",
              "name": "name",
              "scope": "public",
              "parameters": [],
              "statements": [
                "return delegate.getString(\"name\");"
              ],
              "annotations": []
            }
          ],
          "constructors": [
            {
              "name": "Statement",
              "scope": "public",
              "parameters": [
                {
                  "name": "delegate",
                  "type": "io.vertx.core.json.JsonObject"
                }
              ],
              "statements": [
                "this.delegate = delegate;"
              ],
              "annotations": []
            }
          ],
          "nested": [],
          "annotations": [],
          "typeParameters": []
        },
        {
          "name": "Enum",
          "scope": "public",
          "extends": "",
          "fields": [
            {
              "name": "delegate",
              "type": "io.vertx.core.json.JsonObject"
            }
          ],
          "methods": [
            {
              "type": "String",
              "name": "name",
              "scope": "public",
              "parameters": [],
              "statements": [
                "return delegate.getString(\"name\");"
              ],
              "annotations": []
            },
            {
              "type": "String",
              "name": "values",
              "scope": "public",
              "parameters": [],
              "statements": [
                "return delegate.getString(\"values\");"
              ],
              "annotations": []
            }
          ],
          "constructors": [
            {
              "name": "Enum",
              "scope": "public",
              "parameters": [
                {
                  "name": "delegate",
                  "type": "io.vertx.core.json.JsonObject"
                }
              ],
              "statements": [
                "this.delegate = delegate;"
              ],
              "annotations": []
            }
          ],
          "nested": [],
          "annotations": [],
          "typeParameters": []
        },
        {
          "name": "Method",
          "scope": "public",
          "extends": "",
          "fields": [
            {
              "name": "delegate",
              "type": "io.vertx.core.json.JsonObject"
            }
          ],
          "methods": [
            {
              "type": "String",
              "name": "name",
              "scope": "public",
              "parameters": [],
              "statements": [
                "return delegate.getString(\"name\");"
              ],
              "annotations": []
            },
            {
              "type": "String",
              "name": "type",
              "scope": "public",
              "parameters": [],
              "statements": [
                "return delegate.getString(\"type\");"
              ],
              "annotations": []
            },
            {
              "type": "java.util.stream.Stream<Parameter>",
              "name": "parameters",
              "scope": "public",
              "parameters": [],
              "statements": [
                "return delegate.getJsonArray(\"packages\", new io.vertx.core.json.JsonArray()).stream().map(element -> (io.vertx.core.json.JsonObject) element).map(Parameter::new);"
              ],
              "annotations": []
            },
            {
              "type": "java.util.stream.Stream<Statement>",
              "name": "statements",
              "scope": "public",
              "parameters": [],
              "statements": [
                "return delegate.getJsonArray(\"packages\", new io.vertx.core.json.JsonArray()).stream().map(element -> (io.vertx.core.json.JsonObject) element).map(Statement::new);"
              ],
              "annotations": []
            }
          ],
          "constructors": [
            {
              "name": "Method",
              "scope": "public",
              "parameters": [
                {
                  "name": "delegate",
                  "type": "io.vertx.core.json.JsonObject"
                }
              ],
              "statements": [
                "this.delegate = delegate;"
              ],
              "annotations": []
            }
          ],
          "nested": [],
          "annotations": [],
          "typeParameters": []
        },
        {
          "name": "Package",
          "scope": "public",
          "extends": "",
          "fields": [
            {
              "name": "delegate",
              "type": "io.vertx.core.json.JsonObject"
            }
          ],
          "methods": [
            {
              "type": "String",
              "name": "name",
              "scope": "public",
              "parameters": [],
              "statements": [
                "return delegate.getString(\"name\");"
              ],
              "annotations": []
            },
            {
              "type": "java.util.stream.Stream<Entity>",
              "name": "entities",
              "scope": "public",
              "parameters": [],
              "statements": [
                "return delegate.getJsonArray(\"entities\", new io.vertx.core.json.JsonArray()).stream().map(element -> (io.vertx.core.json.JsonObject) element).map(Entity::new);"
              ],
              "annotations": []
            },
            {
              "type": "java.util.stream.Stream<Enum>",
              "name": "enums",
              "scope": "public",
              "parameters": [],
              "statements": [
                "return delegate.getJsonArray(\"enums\", new io.vertx.core.json.JsonArray()).stream().map(element -> (io.vertx.core.json.JsonObject) element).map(Enum::new);"
              ],
              "annotations": []
            },
            {
              "type": "java.util.stream.Stream<Interface>",
              "name": "interfaces",
              "scope": "public",
              "parameters": [],
              "statements": [
                "return delegate.getJsonArray(\"interfaces\", new io.vertx.core.json.JsonArray()).stream().map(element -> (io.vertx.core.json.JsonObject) element).map(Interface::new);"
              ],
              "annotations": []
            }
          ],
          "constructors": [
            {
              "name": "Package",
              "scope": "public",
              "parameters": [
                {
                  "name": "delegate",
                  "type": "io.vertx.core.json.JsonObject"
                }
              ],
              "statements": [
                "this.delegate = delegate;"
              ],
              "annotations": []
            }
          ],
          "nested": [],
          "annotations": [],
          "typeParameters": []
        },
        {
          "name": "Model",
          "scope": "public",
          "extends": "",
          "fields": [
            {
              "name": "path",
              "type": "String"
            },
            {
              "name": "delegate",
              "type": "io.vertx.core.json.JsonObject"
            }
          ],
          "methods": [
            {
              "type": "java.util.stream.Stream<Package>",
              "name": "packages",
              "scope": "public",
              "parameters": [],
              "statements": [
                "return delegate.getJsonArray(\"packages\", new io.vertx.core.json.JsonArray()).stream().map(element -> (io.vertx.core.json.JsonObject) element).map(Package::new);"
              ],
              "annotations": []
            }
          ],
          "constructors": [
            {
              "name": "Model",
              "scope": "public",
              "parameters": [
                {
                  "name": "path",
                  "type": "String"
                }
              ],
              "statements": [
                "this.path = path;"
              ],
              "annotations": []
            }
          ],
          "nested": [],
          "annotations": [],
          "typeParameters": []
        },
        {
          "name": "Interface",
          "scope": "public",
          "extends": "",
          "fields": [
            {
              "name": "delegate",
              "type": "io.vertx.core.json.JsonObject"
            }
          ],
          "methods": [
            {
              "type": "String",
              "name": "name",
              "scope": "public",
              "parameters": [],
              "statements": [
                "return delegate.getString(\"name\");"
              ],
              "annotations": []
            },
            {
              "type": "java.util.stream.Stream<Method>",
              "name": "members",
              "scope": "public",
              "parameters": [],
              "statements": [
                "return delegate.getJsonArray(\"members\", new io.vertx.core.json.JsonArray()).stream().map(element -> (io.vertx.core.json.JsonObject) element).map(Method::new);"
              ],
              "annotations": []
            }
          ],
          "constructors": [
            {
              "name": "Interface",
              "scope": "public",
              "parameters": [
                {
                  "name": "delegate",
                  "type": "io.vertx.core.json.JsonObject"
                }
              ],
              "statements": [
                "this.delegate = delegate;"
              ],
              "annotations": []
            }
          ],
          "nested": [],
          "annotations": [],
          "typeParameters": []
        },
        {
          "name": "Parameter",
          "scope": "public",
          "extends": "",
          "fields": [
            {
              "name": "delegate",
              "type": "io.vertx.core.json.JsonObject"
            }
          ],
          "methods": [
            {
              "type": "String",
              "name": "name",
              "scope": "public",
              "parameters": [],
              "statements": [
                "return delegate.getString(\"name\");"
              ],
              "annotations": []
            },
            {
              "type": "String",
              "name": "type",
              "scope": "public",
              "parameters": [],
              "statements": [
                "return delegate.getString(\"type\");"
              ],
              "annotations": []
            }
          ],
          "constructors": [
            {
              "name": "Parameter",
              "scope": "public",
              "parameters": [
                {
                  "name": "delegate",
                  "type": "io.vertx.core.json.JsonObject"
                }
              ],
              "statements": [
                "this.delegate = delegate;"
              ],
              "annotations": []
            }
          ],
          "nested": [],
          "annotations": [],
          "typeParameters": []
        },
        {
          "name": "Entity",
          "scope": "public",
          "extends": "",
          "fields": [
            {
              "name": "delegate",
              "type": "io.vertx.core.json.JsonObject"
            }
          ],
          "methods": [
            {
              "type": "String",
              "name": "name",
              "scope": "public",
              "parameters": [],
              "statements": [
                "return delegate.getString(\"name\");"
              ],
              "annotations": []
            },
            {
              "type": "java.util.stream.Stream<Field>",
              "name": "fields",
              "scope": "public",
              "parameters": [],
              "statements": [
                "return delegate.getJsonArray(\"fields\", new io.vertx.core.json.JsonArray()).stream().map(element -> (io.vertx.core.json.JsonObject) element).map(Field::new);"
              ],
              "annotations": []
            },
            {
              "type": "java.util.stream.Stream<Method>",
              "name": "methods",
              "scope": "public",
              "parameters": [],
              "statements": [
                "return delegate.getJsonArray(\"methods\", new io.vertx.core.json.JsonArray()).stream().map(element -> (io.vertx.core.json.JsonObject) element).map(Method::new);"
              ],
              "annotations": []
            }
          ],
          "constructors": [
            {
              "name": "Entity",
              "scope": "public",
              "parameters": [
                {
                  "name": "delegate",
                  "type": "io.vertx.core.json.JsonObject"
                }
              ],
              "statements": [
                "this.delegate = delegate;"
              ],
              "annotations": []
            }
          ],
          "nested": [],
          "annotations": [],
          "typeParameters": []
        }
      ],
      "interfaces": [],
      "enums": []
    },
    {
      "name": "nextgen.lambda.domain.ui",
      "entities": [
        {
          "name": "Navigator",
          "scope": "public",
          "extends": "javax.swing.JTree",
          "fields": [
            {
              "name": "root",
              "type": "NavigatorTreeNode"
            }
          ],
          "methods": [],
          "constructors": [
            {
              "name": "Navigator",
              "scope": "public",
              "parameters": [
                {
                  "name": "model",
                  "type": "io.vertx.core.Vertx"
                }
              ],
              "statements": [
                "setModel(new javax.swing.tree.DefaultTreeModel(root = new NavigatorTreeNode(this, model)));",
                "addMouseListener(new java.awt.event.MouseAdapter() {\n\n    @Override\n    public void mouseClicked(java.awt.event.MouseEvent e) {\n        final javax.swing.tree.TreePath selectionPath = getPathForLocation(e.getX(), e.getY());\n        if (selectionPath == null)\n            return;\n        final nextgen.lambda.domain.ui.NavigatorTreeNode selected = (nextgen.lambda.domain.ui.NavigatorTreeNode) selectionPath.getLastPathComponent();\n        if (javax.swing.SwingUtilities.isRightMouseButton(e)) {\n            final javax.swing.JPopupMenu popupMenu = new javax.swing.JPopupMenu();\n            selected.actions().forEach(popupMenu::add);\n            if (popupMenu.getComponentCount() != 0)\n                javax.swing.SwingUtilities.invokeLater(() -> popupMenu.show(nextgen.lambda.domain.ui.Navigator.this, e.getX(), e.getY()));\n        }\n    }\n});"
              ],
              "annotations": []
            }
          ],
          "nested": [],
          "annotations": [],
          "typeParameters": []
        },
        {
          "name": "SelectEventsHandler",
          "scope": "public",
          "extends": "org.piccolo2d.event.PBasicInputEventHandler",
          "fields": [],
          "methods": [],
          "constructors": [],
          "nested": [],
          "annotations": [],
          "typeParameters": []
        },
        {
          "name": "Editor",
          "scope": "public",
          "extends": "javax.swing.JPanel",
          "fields": [
            {
              "name": "ui",
              "type": "UI"
            }
          ],
          "methods": [],
          "constructors": [
            {
              "name": "Editor",
              "scope": "public",
              "parameters": [
                {
                  "name": "ui",
                  "type": "UI"
                }
              ],
              "statements": [
                "this.ui = ui;",
                "setBackground(java.awt.Color.DARK_GRAY);"
              ],
              "annotations": []
            }
          ],
          "nested": [],
          "annotations": [],
          "typeParameters": []
        },
        {
          "name": "CanvasEventHandler",
          "scope": "public",
          "extends": "org.piccolo2d.event.PBasicInputEventHandler",
          "fields": [],
          "methods": [],
          "constructors": [],
          "nested": [],
          "annotations": [],
          "typeParameters": []
        },
        {
          "name": "CanvasZoomHandler",
          "scope": "public",
          "extends": "org.piccolo2d.event.PBasicInputEventHandler",
          "fields": [],
          "methods": [],
          "constructors": [],
          "nested": [],
          "annotations": [],
          "typeParameters": []
        },
        {
          "name": "Action",
          "scope": "public",
          "extends": "javax.swing.AbstractAction",
          "fields": [
            {
              "name": "task",
              "type": "nextgen.lambda.domain.actions.Task"
            }
          ],
          "methods": [
            {
              "type": "void",
              "name": "actionPerformed",
              "scope": "public",
              "parameters": [
                {
                  "name": "event",
                  "type": "java.awt.event.ActionEvent"
                }
              ],
              "statements": [
                "try {\n    task.run();\n} catch (Throwable e) {\n    throw new RuntimeException(e);\n}"
              ],
              "annotations": [
                {
                  "name": "Override"
                }
              ]
            }
          ],
          "constructors": [
            {
              "name": "Action",
              "scope": "public",
              "parameters": [
                {
                  "name": "name",
                  "type": "String"
                },
                {
                  "name": "task",
                  "type": "nextgen.lambda.domain.actions.Task"
                }
              ],
              "statements": [
                "super(name);",
                "this.task = task;"
              ],
              "annotations": []
            }
          ],
          "nested": [],
          "annotations": [],
          "typeParameters": []
        },
        {
          "name": "NavigatorTreeNode",
          "scope": "public",
          "extends": "javax.swing.tree.DefaultMutableTreeNode",
          "fields": [
            {
              "name": "icon",
              "type": "javax.swing.Icon"
            },
            {
              "name": "tooltip",
              "type": "String"
            },
            {
              "name": "navigator",
              "type": "Navigator"
            }
          ],
          "methods": [
            {
              "type": "java.util.Collection<Action>",
              "name": "actions",
              "scope": "public",
              "parameters": [],
              "statements": [
                "return java.util.Collections.emptyList();"
              ],
              "annotations": []
            },
            {
              "type": "javax.swing.tree.DefaultTreeModel",
              "name": "treeModel",
              "scope": "public",
              "parameters": [],
              "statements": [
                "return (javax.swing.tree.DefaultTreeModel) navigator.getModel();"
              ],
              "annotations": []
            },
            {
              "type": "void",
              "name": "addModel",
              "scope": "public",
              "parameters": [
                {
                  "name": "model",
                  "type": "Object"
                }
              ],
              "statements": [
                "final NavigatorTreeNode child = new NavigatorTreeNode(navigator, model);",
                "int n = getChildCount();",
                "if (n == 0) {\n    add(child);\n    treeModel().nodesWereInserted(this, new int[] { n });\n    return;\n}",
                "for (int i = 0; i < n; i++) {\n    final NavigatorTreeNode node = (NavigatorTreeNode) getChildAt(i);\n    if (node.getUserObject().toString().compareTo(child.getUserObject().toString()) > 0) {\n        insert(child, i);\n        treeModel().nodesWereInserted(this, new int[] { i });\n        return;\n    }\n}",
                "add(child);",
                "treeModel().nodesWereInserted(this, new int[] { n });"
              ],
              "annotations": []
            }
          ],
          "constructors": [
            {
              "name": "NavigatorTreeNode",
              "scope": "public",
              "parameters": [
                {
                  "name": "navigator",
                  "type": "Navigator"
                },
                {
                  "name": "model",
                  "type": "Object"
                }
              ],
              "statements": [
                "super(model);",
                "this.navigator = navigator;"
              ],
              "annotations": []
            }
          ],
          "nested": [],
          "annotations": [],
          "typeParameters": []
        },
        {
          "name": "Canvas",
          "scope": "public",
          "extends": "org.piccolo2d.PCanvas",
          "fields": [
            {
              "name": "ui",
              "type": "UI"
            },
            {
              "name": "elements",
              "type": "java.util.Map<Object,CanvasElement>"
            },
            {
              "name": "selectEventHandler",
              "type": "SelectEventsHandler"
            },
            {
              "name": "canvasZoomHandler",
              "type": "CanvasZoomHandler"
            },
            {
              "name": "canvasEventHandler",
              "type": "CanvasEventHandler"
            },
            {
              "name": "highlightedColor",
              "type": "java.awt.Color"
            },
            {
              "name": "selectedColor",
              "type": "java.awt.Color"
            }
          ],
          "methods": [],
          "constructors": [
            {
              "name": "Canvas",
              "scope": "public",
              "parameters": [
                {
                  "name": "ui",
                  "type": "UI"
                }
              ],
              "statements": [
                "this.ui = ui;",
                "setBackground(java.awt.Color.DARK_GRAY);"
              ],
              "annotations": []
            }
          ],
          "nested": [],
          "annotations": [],
          "typeParameters": []
        },
        {
          "name": "UI",
          "scope": "public",
          "extends": "javax.swing.JFrame",
          "fields": [
            {
              "name": "navigator",
              "type": "Navigator"
            },
            {
              "name": "canvas",
              "type": "Canvas"
            },
            {
              "name": "editor",
              "type": "Editor"
            }
          ],
          "methods": [
            {
              "type": "void",
              "name": "showUI",
              "scope": "public",
              "parameters": [
                {
                  "name": "onClose",
                  "type": "Runnable"
                }
              ],
              "statements": [
                "final java.awt.Dimension screenSize = java.awt.Toolkit.getDefaultToolkit().getScreenSize();",
                "final java.awt.Dimension preferredSize = new java.awt.Dimension(800, 768);",
                "setMinimumSize(preferredSize);",
                "setPreferredSize(preferredSize);",
                "setMaximumSize(screenSize);",
                "setSize(preferredSize);",
                "final javax.swing.JPanel contentPanel = new javax.swing.JPanel(new java.awt.BorderLayout());",
                "contentPanel.add(navigator, java.awt.BorderLayout.WEST);",
                "contentPanel.add(canvas, java.awt.BorderLayout.CENTER);",
                "contentPanel.add(editor, java.awt.BorderLayout.EAST);",
                "getContentPane().add(contentPanel, java.awt.BorderLayout.CENTER);",
                "addWindowListener(new java.awt.event.WindowAdapter() {\n\n    @Override\n    public void windowClosed(java.awt.event.WindowEvent e) {\n        onClose.run();\n    }\n});",
                "javax.swing.SwingUtilities.invokeLater(() -> {\n    pack();\n    setLocationByPlatform(true);\n    setVisible(true);\n});"
              ],
              "annotations": []
            }
          ],
          "constructors": [],
          "nested": [],
          "annotations": [],
          "typeParameters": []
        },
        {
          "name": "CanvasElement",
          "scope": "public",
          "extends": "org.piccolo2d.PNode",
          "fields": [],
          "methods": [],
          "constructors": [],
          "nested": [],
          "annotations": [],
          "typeParameters": []
        }
      ],
      "interfaces": [],
      "enums": []
    },
    {
      "name": "nextgen.lambda.domain.os",
      "entities": [
        {
          "name": "OS",
          "scope": "public",
          "extends": "",
          "fields": [],
          "methods": [],
          "constructors": [],
          "nested": [],
          "annotations": [],
          "typeParameters": []
        },
        {
          "name": "File",
          "scope": "public",
          "extends": "",
          "fields": [],
          "methods": [],
          "constructors": [],
          "nested": [],
          "annotations": [],
          "typeParameters": []
        },
        {
          "name": "Directory",
          "scope": "public",
          "extends": "",
          "fields": [],
          "methods": [],
          "constructors": [],
          "nested": [],
          "annotations": [],
          "typeParameters": []
        }
      ],
      "interfaces": [],
      "enums": []
    },
    {
      "name": "nextgen.lambda.ui",
      "entities": [
        {
          "name": "Navigator",
          "scope": "public",
          "extends": "UIComponent",
          "fields": [],
          "methods": [],
          "constructors": [
            {
              "name": "Navigator",
              "scope": "public",
              "parameters": [
                {
                  "name": "ui",
                  "type": "UI"
                }
              ],
              "statements": [
                "super(ui);",
                "setBackground(ui().getBackground());",
                "add(new JScrollPane(new NavigatorTree(this)), BorderLayout.CENTER);"
              ],
              "annotations": []
            }
          ],
          "nested": [],
          "annotations": [],
          "typeParameters": []
        },
        {
          "name": "Editor",
          "scope": "public",
          "extends": "UIComponent",
          "fields": [],
          "methods": [],
          "constructors": [
            {
              "name": "Editor",
              "scope": "public",
              "parameters": [
                {
                  "name": "ui",
                  "type": "UI"
                }
              ],
              "statements": [
                "super(ui);",
                "setBackground(ui().getBackground());",
                "add(new EditorPanel(this), BorderLayout.CENTER);"
              ],
              "annotations": []
            }
          ],
          "nested": [],
          "annotations": [],
          "typeParameters": []
        },
        {
          "name": "UIComponent",
          "scope": "public",
          "extends": "JPanel",
          "fields": [
            {
              "name": "ui",
              "type": "UI"
            }
          ],
          "methods": [
            {
              "type": "UI",
              "name": "ui",
              "scope": "",
              "parameters": [],
              "statements": [
                "return ui;"
              ],
              "annotations": []
            }
          ],
          "constructors": [
            {
              "name": "UIComponent",
              "scope": "",
              "parameters": [
                {
                  "name": "ui",
                  "type": "UI"
                }
              ],
              "statements": [
                "super(new BorderLayout(), true);",
                "this.ui = ui;",
                "setSize(ui.getPreferredSize());",
                "setMinimumSize(ui.getMinimumSize());",
                "setPreferredSize(ui.getPreferredSize());",
                "setMaximumSize(ui.getMaximumSize());"
              ],
              "annotations": []
            }
          ],
          "nested": [],
          "annotations": [],
          "typeParameters": []
        },
        {
          "name": "Canvas",
          "scope": "public",
          "extends": "UIComponent",
          "fields": [],
          "methods": [],
          "constructors": [
            {
              "name": "Canvas",
              "scope": "public",
              "parameters": [
                {
                  "name": "ui",
                  "type": "UI"
                }
              ],
              "statements": [
                "super(ui);",
                "setBackground(ui().getBackground());",
                "add(new ContextCanvas(), BorderLayout.CENTER);"
              ],
              "annotations": []
            }
          ],
          "nested": [],
          "annotations": [],
          "typeParameters": []
        },
        {
          "name": "UI",
          "scope": "public",
          "extends": "JFrame",
          "fields": [
            {
              "name": "FONT",
              "type": "Font"
            },
            {
              "name": "iconCache",
              "type": "Map<Color,ImageIcon>"
            }
          ],
          "methods": [
            {
              "type": "void",
              "name": "main",
              "scope": "public static",
              "parameters": [
                {
                  "name": "args",
                  "type": "String[]"
                }
              ],
              "statements": [
                "try {\n    UIManager.setLookAndFeel(new com.formdev.flatlaf.FlatDarculaLaf());\n} catch (UnsupportedLookAndFeelException ignore) {\n}",
                "new UI().showUI();"
              ],
              "annotations": []
            },
            {
              "type": "void",
              "name": "onEvent",
              "scope": "public",
              "parameters": [
                {
                  "name": "event",
                  "type": "Object"
                }
              ],
              "statements": [
                "System.out.println(event);"
              ],
              "annotations": [
                {
                  "name": "Subscribe"
                }
              ]
            },
            {
              "type": "void",
              "name": "showPopup",
              "scope": "",
              "parameters": [
                {
                  "name": "e",
                  "type": "MouseEvent"
                },
                {
                  "name": "actions",
                  "type": "Supplier<Collection<Action>>"
                }
              ],
              "statements": [
                "SwingUtilities.invokeLater(() -> getPop(actions.get()).show(e.getComponent(), e.getX(), e.getY()));"
              ],
              "annotations": []
            },
            {
              "type": "void",
              "name": "showPopup",
              "scope": "",
              "parameters": [
                {
                  "name": "canvas",
                  "type": "Canvas"
                },
                {
                  "name": "e",
                  "type": "PInputEvent"
                },
                {
                  "name": "actions",
                  "type": "Supplier<Collection<Action>>"
                }
              ],
              "statements": [
                "SwingUtilities.invokeLater(() -> {\n    final Point2D canvasPosition = e.getCanvasPosition();\n    SwingUtilities.invokeLater(() -> getPop(actions.get()).show(canvas, (int) canvasPosition.getX(), (int) canvasPosition.getY()));\n});"
              ],
              "annotations": []
            },
            {
              "type": "JPopupMenu",
              "name": "getPop",
              "scope": "",
              "parameters": [
                {
                  "name": "actions",
                  "type": "Collection<Action>"
                }
              ],
              "statements": [
                "final JPopupMenu pop = new JPopupMenu();",
                "for (Action action : actions) pop.add(action);",
                "return pop;"
              ],
              "annotations": []
            },
            {
              "type": "Icon",
              "name": "squareIcon",
              "scope": "",
              "parameters": [
                {
                  "name": "color",
                  "type": "Color"
                }
              ],
              "statements": [
                "if (iconCache.containsKey(color))\n    return iconCache.get(color);",
                "final BufferedImage bim = new BufferedImage(16, 16, BufferedImage.TYPE_INT_ARGB);",
                "final Graphics2D g2 = bim.createGraphics();",
                "g2.setPaint(color);",
                "g2.fillRect(0, 0, 16, 16);",
                "g2.dispose();",
                "final ImageIcon icon = new ImageIcon(bim);",
                "iconCache.put(color, icon);",
                "return icon;"
              ],
              "annotations": []
            },
            {
              "type": "void",
              "name": "post",
              "scope": "",
              "parameters": [
                {
                  "name": "object",
                  "type": "Object"
                }
              ],
              "statements": [
                "EventBus.getDefault().post(object);"
              ],
              "annotations": []
            },
            {
              "type": "void",
              "name": "showUI",
              "scope": "private",
              "parameters": [],
              "statements": [
                "SwingUtilities.invokeLater(() -> {\n    pack();\n    setLocationByPlatform(true);\n    setVisible(true);\n});"
              ],
              "annotations": []
            },
            {
              "type": "void",
              "name": "runKeyAction",
              "scope": "public",
              "parameters": [
                {
                  "name": "event",
                  "type": "PInputEvent"
                },
                {
                  "name": "actions",
                  "type": "Collection<Action>"
                }
              ],
              "statements": [
                "final String keyText = String.join(\" \", event.isControlDown() ? \"control\" : \"\", KeyEvent.getKeyText(event.getKeyCode()));",
                "actions.stream().filter(action -> keyText.equals(action.getValue(Action.ACTION_COMMAND_KEY))).findFirst().ifPresent(action -> action.actionPerformed(null));"
              ],
              "annotations": []
            }
          ],
          "constructors": [
            {
              "name": "UI",
              "scope": "public",
              "parameters": [],
              "statements": [
                "super(\"\\u03BB\");",
                "final Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();",
                "final Dimension preferredSize = new Dimension((int) (screenSize.width * .75d), (int) (screenSize.height * .75d));",
                "final Dimension minimumSize = new Dimension(100, 100);",
                "setMinimumSize(minimumSize);",
                "setPreferredSize(preferredSize);",
                "setMaximumSize(screenSize);",
                "add(new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, new Navigator(this), new Canvas(this)), new Editor(this)), BorderLayout.CENTER);",
                "EventBus.getDefault().register(this);"
              ],
              "annotations": []
            }
          ],
          "nested": [],
          "annotations": [],
          "typeParameters": []
        }
      ],
      "interfaces": [],
      "enums": []
    },
    {
      "name": "nextgen.lambda",
      "entities": [
        {
          "name": "Lambda",
          "scope": "public",
          "extends": "",
          "fields": [],
          "methods": [
            {
              "type": "void",
              "name": "main",
              "scope": "public static",
              "parameters": [
                {
                  "name": "args",
                  "type": "String[]"
                }
              ],
              "statements": [
                "final io.vertx.core.VertxOptions options = new io.vertx.core.VertxOptions();",
                "final io.vertx.core.Vertx vertx = io.vertx.core.Vertx.vertx(options);",
                "final FileSystem fileSystem = vertx.fileSystem();",
                "final io.vertx.core.eventbus.EventBus eventBus = vertx.eventBus();",
                "final nextgen.lambda.domain.maven.Project project = new nextgen.lambda.domain.maven.Project(\"Lambda\", \".\");",
                "final String modelPath = join(separator, project.srcMainResources(), \"lambda.json\");",
                "final String templatePath = join(separator, project.srcMainResources(), \"Java.json\");",
                "final nextgen.lambda.domain.core.Model model = new nextgen.lambda.domain.core.Model(modelPath);",
                "final org.stringtemplate.v4.STGroup stGroup = new org.stringtemplate.v4.STGroupFile(join(separator, project.srcMainResources(), \"Java.stg\"));",
                "stgToJson(fileSystem, stGroup);",
                "try {\n    javax.swing.UIManager.setLookAndFeel(new com.formdev.flatlaf.FlatDarculaLaf());\n} catch (javax.swing.UnsupportedLookAndFeelException ignore) {\n}",
                "final nextgen.lambda.domain.ui.UI ui = new nextgen.lambda.domain.ui.UI();",
                "ui.setTitle(\"\\u03BB\");",
                "ui.navigator = new nextgen.lambda.domain.ui.Navigator(vertx);",
                "ui.canvas = new nextgen.lambda.domain.ui.Canvas(ui);",
                "ui.editor = new nextgen.lambda.domain.ui.Editor(ui);",
                "fileSystem.readFile(modelPath, ar -> {\n    if (ar.failed())\n        throw new RuntimeException(ar.cause());\n    model.delegate = new JsonObject(ar.result());\n    parse(modelPath, fileSystem, model.delegate);\n});",
                "fileSystem.readFile(templatePath, ar -> {\n    if (ar.failed())\n        throw new RuntimeException(ar.cause());\n    final nextgen.lambda.domain.templates.TemplateGroup templateGroup = new nextgen.lambda.domain.templates.TemplateGroup(new io.vertx.core.json.JsonObject(ar.result()));\n});",
                "ui.showUI(() -> System.exit(0));"
              ],
              "annotations": []
            },
            {
              "type": "void",
              "name": "stgToJson",
              "scope": "private static",
              "parameters": [
                {
                  "name": "fileSystem",
                  "type": "io.vertx.core.file.FileSystem"
                },
                {
                  "name": "stGroup",
                  "type": "org.stringtemplate.v4.STGroup"
                }
              ],
              "statements": [
                "final io.vertx.core.json.JsonObject tmp = new io.vertx.core.json.JsonObject();",
                "tmp.put(\"name\", stGroup.getName());",
                "tmp.put(\"templates\", new io.vertx.core.json.JsonArray());",
                "stGroup.getTemplateNames().stream().filter(templateName -> !templateName.contains(\"_sub\")).forEach(templateName -> {\n    final io.vertx.core.json.JsonObject template = new io.vertx.core.json.JsonObject();\n    template.put(\"name\", templateName.substring(1));\n    final org.stringtemplate.v4.compiler.CompiledST compiledST = stGroup.lookupTemplate(templateName);\n    template.put(\"content\", compiledST.template);\n    final io.vertx.core.json.JsonArray parameters = new io.vertx.core.json.JsonArray();\n    java.util.Optional.ofNullable(compiledST.formalArguments).ifPresent(arguments -> {\n        arguments.forEach((pName, argument) -> {\n            final io.vertx.core.json.JsonObject parameter = new io.vertx.core.json.JsonObject();\n            parameter.put(\"name\", pName);\n            parameter.put(\"qty\", compiledST.template.contains(\"~\" + pName + \":{\") ? \"MANY\" : \"ONE\");\n            parameters.add(parameter);\n        });\n    });\n    if (!parameters.isEmpty())\n        template.put(\"parameters\", parameters);\n    tmp.getJsonArray(\"templates\").add(template);\n});",
                "fileSystem.writeFile(\"/home/goe/github/lambda/src/main/resources/\" + stGroup.getName() + \".json\", tmp.toBuffer(), ar2 -> {\n    if (ar2.failed())\n        throw new RuntimeException(ar2.cause());\n    System.out.println(\"/home/goe/github/lambda/src/main/resources/\" + stGroup.getName() + \".json\");\n});"
              ],
              "annotations": []
            },
            {
              "type": "java.util.Optional<String>",
              "name": "singleInput",
              "scope": "public static",
              "parameters": [
                {
                  "name": "parent",
                  "type": "javax.swing.JComponent"
                },
                {
                  "name": "message",
                  "type": "String"
                },
                {
                  "name": "initial",
                  "type": "String"
                }
              ],
              "statements": [
                "final String s = javax.swing.JOptionPane.showInputDialog(parent, message, initial);",
                "if (s == null || s.trim().length() == 0)\n    return java.util.Optional.empty();",
                "return java.util.Optional.of(s.trim());"
              ],
              "annotations": []
            },
            {
              "type": "void",
              "name": "toClipboard",
              "scope": "public static",
              "parameters": [
                {
                  "name": "s",
                  "type": "String"
                }
              ],
              "statements": [
                "java.awt.Toolkit.getDefaultToolkit().getSystemClipboard().setContents(new java.awt.datatransfer.StringSelection(s), (cp, contents) -> System.out.println(contents.toString()));"
              ],
              "annotations": []
            },
            {
              "type": "java.util.Optional<String>",
              "name": "fromClipboard",
              "scope": "public static",
              "parameters": [],
              "statements": [
                "final java.awt.datatransfer.Transferable contents = java.awt.Toolkit.getDefaultToolkit().getSystemClipboard().getContents(null);",
                "if ((contents != null) && contents.isDataFlavorSupported(java.awt.datatransfer.DataFlavor.stringFlavor)) {\n    try {\n        final String data = (String) contents.getTransferData(java.awt.datatransfer.DataFlavor.stringFlavor);\n        return data.trim().length() == 0 ? java.util.Optional.empty() : java.util.Optional.of(data);\n    } catch (Exception e) {\n        return java.util.Optional.empty();\n    }\n}",
                "return java.util.Optional.empty();"
              ],
              "annotations": []
            },
            {
              "type": "java.util.Optional<org.stringtemplate.v4.ST>",
              "name": "mapClassDeclaration",
              "scope": "public static",
              "parameters": [
                {
                  "name": "stGroup",
                  "type": "STGroup"
                },
                {
                  "name": "model",
                  "type": "io.vertx.core.json.JsonObject"
                },
                {
                  "name": "map",
                  "type": "io.vertx.core.json.JsonObject"
                }
              ],
              "statements": [
                "final org.stringtemplate.v4.ST template = stGroup.getInstanceOf(map.getString(\"templateName\"));",
                "streamJsonObjects(\"ONE\", map).forEach(one -> {\n    try {\n        final JsonObject mapper = one.getJsonObject(\"mapper\");\n        if (mapper != null)\n            mapClassDeclaration(stGroup, one, mapper).ifPresent(mapped -> template.add(one.getString(\"template\"), mapped));\n        else {\n            final Object value = model.getValue(one.getString(\"model\"));\n            if (value != null && value.toString().trim().length() > 0)\n                template.add(one.getString(\"template\"), value);\n        }\n    } catch (Throwable throwable) {\n        System.err.println(\"ERROR with \" + template.getName());\n        System.err.println(\"\\t\" + throwable.getMessage());\n    }\n});",
                "streamJsonObjects(\"MANY\", map).forEach(many -> {\n    try {\n        final io.vertx.core.json.JsonObject mapper = many.getJsonObject(\"mapper\");\n        if (mapper != null)\n            streamJsonObjects(many.getString(\"model\"), model).forEach(manyElement -> mapClassDeclaration(stGroup, manyElement, mapper).ifPresent(mapped -> template.add(many.getString(\"template\"), mapped)));\n        else\n            streamObjects(many.getString(\"model\"), model).forEach(manyElement -> template.add(many.getString(\"template\"), manyElement));\n    } catch (Throwable throwable) {\n        System.err.println(\"ERROR with \" + template.getName());\n        System.err.println(\"\\t\" + throwable.getMessage());\n    }\n});",
                "return java.util.Optional.of(template);"
              ],
              "annotations": []
            },
            {
              "type": "java.util.stream.Stream<java.nio.file.Path>",
              "name": "files",
              "scope": "public static",
              "parameters": [
                {
                  "name": "path",
                  "type": "String"
                },
                {
                  "name": "postfix",
                  "type": "String"
                }
              ],
              "statements": [
                "return java.nio.file.Files.walk(java.nio.file.Paths.get(path)).filter(java.nio.file.Files::isRegularFile).filter(file -> file.toString().endsWith(postfix));"
              ],
              "annotations": []
            },
            {
              "type": "void",
              "name": "write",
              "scope": "private static",
              "parameters": [
                {
                  "name": "fileSystem",
                  "type": "io.vertx.core.file.FileSystem"
                },
                {
                  "name": "compilationUnit",
                  "type": "org.stringtemplate.v4.ST"
                },
                {
                  "name": "file",
                  "type": "String"
                }
              ],
              "statements": [
                "fileSystem.writeFile(file, io.vertx.core.buffer.Buffer.buffer(compilationUnit.render()), ar2 -> {\n    if (ar2.failed())\n        throw new RuntimeException(ar2.cause());\n    System.out.println(file);\n});"
              ],
              "annotations": []
            },
            {
              "type": "JsonObject",
              "name": "decorate",
              "scope": "static",
              "parameters": [
                {
                  "name": "model",
                  "type": "JsonObject"
                }
              ],
              "statements": [
                "if (model.getString(\"scope\") == null)\n    model.put(\"scope\", \"public\");",
                "streamJsonObjects(\"fields\", model).forEach(field -> {\n    if (field.getString(\"scope\") == null)\n        field.put(\"scope\", \"public\");\n});",
                "streamJsonObjects(\"methods\", model).forEach(method -> {\n    if (method.getString(\"scope\") == null)\n        method.put(\"scope\", \"public\");\n});",
                "streamJsonObjects(\"constructors\", model).forEach(method -> {\n    if (method.getString(\"scope\") == null)\n        method.put(\"scope\", \"public\");\n    if (method.getString(\"name\") == null)\n        method.put(\"name\", model.getString(\"name\"));\n});",
                "streamJsonObjects(\"nested\", model).forEach(nextgen.lambda.Lambda::decorate);",
                "return model;"
              ],
              "annotations": []
            },
            {
              "type": "void",
              "name": "parse",
              "scope": "private static",
              "parameters": [
                {
                  "name": "path",
                  "type": "String"
                },
                {
                  "name": "fileSystem",
                  "type": "FileSystem"
                },
                {
                  "name": "lambda",
                  "type": "JsonObject"
                }
              ],
              "statements": [
                "final JsonArray packages = lambda.getJsonArray(\"packages\");",
                "final JsonObject aPackage = new JsonObject();",
                "aPackage.put(\"name\", path.substring(path.indexOf(\"java/\") + 5).replaceAll(separator, \".\"));",
                "aPackage.put(\"entities\", new JsonArray());",
                "aPackage.put(\"interfaces\", new JsonArray());",
                "aPackage.put(\"enums\", new JsonArray());",
                "fileSystem.readDir(path, ar -> {\n    if (ar.failed())\n        throw new RuntimeException(ar.cause());\n    ar.result().forEach(file -> {\n        if (file.endsWith(\".java\")) {\n            try {\n                StaticJavaParser.parse(java.nio.file.Path.of(file)).getTypes().forEach(typeDeclaration -> {\n                    typeDeclaration.ifClassOrInterfaceDeclaration(classOrInterfaceDeclaration -> {\n                        if (classOrInterfaceDeclaration.isInterface()) {\n                            aPackage.getJsonArray(\"interfaces\").add(mapClassDeclaration(classOrInterfaceDeclaration));\n                        } else {\n                            aPackage.getJsonArray(\"entities\").add(mapClassDeclaration(classOrInterfaceDeclaration));\n                        }\n                    });\n                    typeDeclaration.ifEnumDeclaration(enumDeclaration -> {\n                        aPackage.getJsonArray(\"enums\").add(mapEnumDeclaration(enumDeclaration));\n                    });\n                });\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        } else if (!file.contains(\".\")) {\n            parse(file, fileSystem, lambda);\n        }\n    });\n});"
              ],
              "annotations": []
            },
            {
              "type": "JsonObject",
              "name": "mapEnumDeclaration",
              "scope": "public static",
              "parameters": [
                {
                  "name": "declaration",
                  "type": "EnumDeclaration"
                }
              ],
              "statements": [
                "final JsonObject model = new JsonObject();",
                "model.put(\"name\", declaration.getName().asString());",
                "model.put(\"scope\", declaration.getModifiers().stream().map(modifier -> modifier.getKeyword().asString()).collect(java.util.stream.Collectors.joining(\" \")));",
                "model.put(\"values\", new JsonArray());",
                "declaration.getEntries().forEach(element -> model.getJsonArray(\"values\").add(element.getNameAsString()));",
                "return model;"
              ],
              "annotations": []
            },
            {
              "type": "JsonObject",
              "name": "mapClassDeclaration",
              "scope": "public static",
              "parameters": [
                {
                  "name": "declaration",
                  "type": "ClassOrInterfaceDeclaration"
                }
              ],
              "statements": [
                "final JsonObject model = new JsonObject();",
                "model.put(\"name\", declaration.getName().asString());",
                "model.put(\"scope\", declaration.getModifiers().stream().map(element -> element.getKeyword().asString()).collect(java.util.stream.Collectors.joining(\" \")));",
                "model.put(\"extends\", declaration.getExtendedTypes().stream().map(com.github.javaparser.ast.type.ClassOrInterfaceType::asString).collect(java.util.stream.Collectors.joining(\", \")));",
                "model.put(\"fields\", new JsonArray());",
                "model.put(\"methods\", new JsonArray());",
                "model.put(\"constructors\", new JsonArray());",
                "model.put(\"nested\", new JsonArray());",
                "model.put(\"annotations\", new io.vertx.core.json.JsonArray());",
                "model.put(\"typeParameters\", new io.vertx.core.json.JsonArray());",
                "declaration.getTypeParameters().forEach(element -> model.getJsonArray(\"typeParameters\").add(element.getName().asString()));",
                "declaration.getAnnotations().stream().map(nextgen.lambda.Lambda::mapAnnotation).forEach(element -> model.getJsonArray(\"annotations\").add(element));",
                "declaration.getFields().forEach(fieldDeclaration -> fieldDeclaration.getVariables().forEach(variableDeclaration -> model.getJsonArray(\"fields\").add(mapFieldDeclaration(variableDeclaration))));",
                "declaration.getMethods().forEach(methodDeclaration -> {\n    model.getJsonArray(\"methods\").add(mapMethodDeclaration(methodDeclaration));\n});",
                "declaration.getConstructors().forEach(constructorDeclaration -> model.getJsonArray(\"constructors\").add(mapConstructorDeclaration(constructorDeclaration)));",
                "// typeDeclaration.getMembers().stream().filter(BodyDeclaration::isClassOrInterfaceDeclaration).map(BodyDeclaration::asClassOrInterfaceDeclaration).forEach(classOrInterfaceDeclaration -> entity.getJsonArray(\"nested\").add(mapEntity(classOrInterfaceDeclaration)));\nreturn model;"
              ],
              "annotations": []
            },
            {
              "type": "io.vertx.core.json.JsonObject",
              "name": "mapAnnotation",
              "scope": "private static",
              "parameters": [
                {
                  "name": "element",
                  "type": "com.github.javaparser.ast.expr.AnnotationExpr"
                }
              ],
              "statements": [
                "return new io.vertx.core.json.JsonObject().put(\"name\", element.getName().asString());"
              ],
              "annotations": []
            },
            {
              "type": "io.vertx.core.json.JsonObject",
              "name": "mapConstructorDeclaration",
              "scope": "private static",
              "parameters": [
                {
                  "name": "declaration",
                  "type": "com.github.javaparser.ast.body.ConstructorDeclaration"
                }
              ],
              "statements": [
                "final io.vertx.core.json.JsonObject model = new io.vertx.core.json.JsonObject();",
                "model.put(\"name\", declaration.getNameAsString());",
                "model.put(\"scope\", declaration.getModifiers().stream().map(modifier -> modifier.getKeyword().asString()).collect(java.util.stream.Collectors.joining(\" \")));",
                "model.put(\"parameters\", new io.vertx.core.json.JsonArray());",
                "model.put(\"statements\", new io.vertx.core.json.JsonArray());",
                "model.put(\"annotations\", new io.vertx.core.json.JsonArray());",
                "declaration.getAnnotations().stream().map(nextgen.lambda.Lambda::mapAnnotation).forEach(element -> model.getJsonArray(\"annotations\").add(element));",
                "declaration.getParameters().forEach(parameterDeclaration -> model.getJsonArray(\"parameters\").add(mapParameter(parameterDeclaration)));",
                "declaration.getBody().getStatements().forEach(statement -> model.getJsonArray(\"statements\").add(statement.toString()));",
                "return model;"
              ],
              "annotations": []
            },
            {
              "type": "io.vertx.core.json.JsonObject",
              "name": "mapMethodDeclaration",
              "scope": "private static",
              "parameters": [
                {
                  "name": "declaration",
                  "type": "com.github.javaparser.ast.body.MethodDeclaration"
                }
              ],
              "statements": [
                "final io.vertx.core.json.JsonObject model = new io.vertx.core.json.JsonObject();",
                "model.put(\"type\", declaration.getTypeAsString());",
                "model.put(\"name\", declaration.getNameAsString());",
                "model.put(\"scope\", declaration.getModifiers().stream().map(modifier -> modifier.getKeyword().asString()).collect(java.util.stream.Collectors.joining(\" \")));",
                "model.put(\"parameters\", new io.vertx.core.json.JsonArray());",
                "model.put(\"statements\", new io.vertx.core.json.JsonArray());",
                "model.put(\"annotations\", new io.vertx.core.json.JsonArray());",
                "declaration.getAnnotations().stream().map(nextgen.lambda.Lambda::mapAnnotation).forEach(element -> model.getJsonArray(\"annotations\").add(element));",
                "declaration.getParameters().forEach(parameterDeclaration -> {\n    final io.vertx.core.json.JsonObject parameter = mapParameter(parameterDeclaration);\n    model.getJsonArray(\"parameters\").add(parameter);\n});",
                "declaration.getBody().ifPresent(blockStmt -> blockStmt.getStatements().forEach(statement -> model.getJsonArray(\"statements\").add(statement.toString())));",
                "return model;"
              ],
              "annotations": []
            },
            {
              "type": "io.vertx.core.json.JsonObject",
              "name": "mapParameter",
              "scope": "private static",
              "parameters": [
                {
                  "name": "declaration",
                  "type": "com.github.javaparser.ast.body.Parameter"
                }
              ],
              "statements": [
                "final io.vertx.core.json.JsonObject parameter = new io.vertx.core.json.JsonObject();",
                "parameter.put(\"name\", declaration.getNameAsString());",
                "parameter.put(\"type\", declaration.getTypeAsString());",
                "return parameter;"
              ],
              "annotations": []
            },
            {
              "type": "io.vertx.core.json.JsonObject",
              "name": "mapFieldDeclaration",
              "scope": "public static",
              "parameters": [
                {
                  "name": "declaration",
                  "type": "com.github.javaparser.ast.body.VariableDeclarator"
                }
              ],
              "statements": [
                "final io.vertx.core.json.JsonObject model = new io.vertx.core.json.JsonObject();",
                "model.put(\"name\", declaration.getNameAsString());",
                "model.put(\"type\", declaration.getTypeAsString());",
                "return model;"
              ],
              "annotations": []
            },
            {
              "type": "Stream<Object>",
              "name": "streamObjects",
              "scope": "public static",
              "parameters": [
                {
                  "name": "name",
                  "type": "String"
                },
                {
                  "name": "model",
                  "type": "JsonObject"
                }
              ],
              "statements": [
                "return model.getJsonArray(name, new JsonArray()).stream();"
              ],
              "annotations": []
            },
            {
              "type": "Stream<JsonObject>",
              "name": "streamJsonObjects",
              "scope": "public static",
              "parameters": [
                {
                  "name": "name",
                  "type": "String"
                },
                {
                  "name": "model",
                  "type": "JsonObject"
                }
              ],
              "statements": [
                "return model.getJsonArray(name, new JsonArray()).stream().map(o -> {\n    try {\n        return (JsonObject) o;\n    } catch (Throwable throwable) {\n        throw new RuntimeException(throwable);\n    }\n});"
              ],
              "annotations": []
            }
          ],
          "constructors": [],
          "nested": [],
          "annotations": [],
          "typeParameters": []
        }
      ],
      "interfaces": [],
      "enums": []
    }
  ]
}